# SPDX-License-Identifier: GPL-3.0-or-later
from typing import Dict,List,Union
from math import floor

from symfem.functions import VectorFunction,MatrixFunction

from topoptlab.symbolic.cell import base_cell
from topoptlab.symbolic.parametric_map import jacobian
from topoptlab.symbolic.matrix_utils import simplify_matrix, generate_constMatrix
from topoptlab.symbolic.matrix_utils import eye,to_square,inverse

def small_strain_matrix(ndim: int, nd_inds: List,
                        basis: List,
                        isoparam_kws: Dict) -> MatrixFunction:
    """
    Create the small strain matrix to calculate engineering/infinitesimal 
    strains via
    
    eps = B @ u
    
    where u are nodal displacements and eps_e a column vector of 
    length (ndim**2 + ndim)/2.

    Parameters
    ----------
    ndim : int
        number of spatial dimensions.
    nd_inds : list
        node indices.
    basis : list
        list of basis functions as generated by base_cell.
    isoparam_kws : dictionary
        keywords for the isoparametric mapping.

    Returns
    -------
    bmatrix : symfem.functions.Matrixfunction
        small displacement matrix shape ( (ndim**2+ndim)/2 , n_nodes*ndim ).
    """

    nrows = int((ndim**2 + ndim) /2)
    ncols = int(ndim * len(nd_inds))
    # compute gradients of basis functions
    Jinv = jacobian(ndim=ndim,
                    return_J=False, return_inv=True, return_det=False,
                    **isoparam_kws)
    gradN_T = (VectorFunction(basis).grad(ndim)@Jinv.transpose()).transpose()
    #
    bmatrix = [[0 for j in range(ncols)] for i in range(nrows)]
    # tension
    for i in range(ndim):
        bmatrix[i][i::ndim] = gradN_T[i]
    # shear
    i,j = ndim-2,ndim-1
    for k in range(nrows-ndim):
        #
        bmatrix[ndim+k][i::ndim] = gradN_T[j]
        bmatrix[ndim+k][j::ndim] = gradN_T[i]
        #
        i,j = (i+1)%ndim , (j+1)%ndim
    return MatrixFunction(bmatrix)

def eng_strain(ndim: int,
               element_type: str= "Lagrange",
               order: int = 1) -> MatrixFunction:
    """
    Symbolically compute engineering strain.

    Parameters
    ----------
    ndim : int
        number of spatial dimensions. Must be between 1 and 3.
    element_type : str
        type of element.
    order : int
        order of element.

    Returns
    -------
    eng_strains : MatrixFunction
        engineering strains in Voigt notation shape ( (ndim**2 + ndim)/2 ) .

    """
    #
    vertices, nd_inds, ref, basis  = base_cell(ndim)
    # small strain matrix
    b = small_strain_matrix(ndim=ndim,
                            nd_inds=nd_inds,
                            basis=basis,
                            isoparam_kws={"element_type": element_type,
                                          "order": order})
    # nodal displacements
    u = generate_constMatrix(1,b.shape[1], "u")
    return simplify_matrix( b@u )

def dispgrad_matrix(ndim: int, nd_inds: list,
                    basis: List,
                    isoparam_kws: Dict) -> MatrixFunction:
    """
    Create the matrix to calculate the flattened displacement gradient via
    
    h = B @ u
    
    where u are nodal displacements and h a column vector of length ndim**2. 
    You recover the full deformation gradient by 
    
    H = h.reshape(ndim,ndim).

    Parameters
    ----------
    ndim : int
        number of spatial dimensions.
    nd_inds : list
        node indices.
    basis : list
        list of basis functions as generated by base_cell.
    isoparam_kws : dictionary
        keywords for the isoparametric mapping.

    Returns
    -------
    dispgrad_matrix : symfem.functions.Matrixfunction
        matrix to calculate flattened displacement gradient shape 
        (ndim**2 , n_nodes*ndim).
    """
    #
    nrows = int(ndim**2)
    ncols = int(ndim * len(nd_inds))
    # compute gradients of basis functions
    Jinv = jacobian(ndim=ndim,
                    return_J=False, return_inv=True, return_det=False,
                    **isoparam_kws)
    gradN_T = (VectorFunction(basis).grad(ndim)@Jinv.transpose()).transpose()
    #
    dispgrad_matrix = [[0 for j in range(ncols)] for i in range(nrows)]
    # 
    for i in range(ndim):
        for j in range(ndim): 
            dispgrad_matrix[i*ndim + j][i::ndim] = gradN_T[j]
    return MatrixFunction(dispgrad_matrix)

def disp_grad(ndim: int,
              u: Union[None,MatrixFunction] = None,
              element_type: str = "Lagrange",
              order: int = 1,
              shape: str = "quadratic") -> MatrixFunction:
    """
    Symbolically compute the displacement gradient. If the shape argument is 
    "square", compute 
        
    H_ij = d u_i / d x_j.
    
    If the shape argument is "voigt", flatten H to a (ndim**2,1) Matrixfunction.

    Parameters
    ----------
    ndim : int
        number of spatial dimensions. Must be between 1 and 3.
    u : None or MatrixFunction
        nodal displacements.
    element_type : str
        type of element.
    order : int
        order of element.
    shape : str
        indicate output shape either as a Voigt vector ("voigt") or a square 
        matrix ("square").

    Returns
    -------
    H : symfem.MatrixFunction
        symbolic displacement gradient of shape (ndim,ndim) or (ndim**2,1).

    """
    #
    vertices, nd_inds, ref, basis  = base_cell(ndim)
    # small strain matrix
    b = dispgrad_matrix(ndim=ndim,
                        nd_inds=nd_inds,
                        basis=basis,
                        isoparam_kws={"element_type": element_type,
                                      "order": order})
    # nodal displacements
    u = generate_constMatrix(ncol=1, nrow=b.shape[1], name="u")
    if shape=="square":
        return to_square(v=simplify_matrix(M=b@u), order="C")
    elif shape=="voigt":
        return simplify_matrix(M=b@u) 
    else:
        raise ValueError("shape can only be one of the followings options: ",
                         "square, voigt")

def def_grad(ndim: int,
             u: Union[None,MatrixFunction] = None,
             element_type: str = "Lagrange",
             order: int = 1,
             shape: str = "quadratic"):
    """
    Symbolically compute deformation gradient. If the shape argument is 
    "square", compute 
    
    F_ij = delta_ij + d u_i / d x_j
    
    If the shape argument is "voigt", flatten H to a (ndim**2,1) Matrixfunction.

    Parameters
    ----------
    ndim : int
        number of spatial dimensions. Must be between 1 and 3.
    u : None or MatrixFunction
        nodal displacements.
    element_type : str
        type of element.
    order : int
        order of element.
    shape : str
        indicate output shape either as a Voigt vector ("voigt") or a square 
        matrix ("square").

    Returns
    -------
    F : symfem.MatrixFunction
        symbolic deformation gradient of shape (ndim,ndim) or (ndim**2,1).

    """
    #
    I = eye(size=ndim)
    if shape=="square":
        pass
    elif shape=="voigt":
        I = MatrixFunction([ I[i%ndim, floor(i/ndim)] for i in range(ndim**2) ])
    else:
        raise ValueError("shape can only be one of the followings options: ",
                         "square, voigt")
    #
    H = disp_grad(ndim=ndim,
                  u=u,
                  element_type=element_type,
                  order=order,
                  shape=shape)
    return I + H

def cauchy_strain(ndim: int,
                  element_type: str = "Lagrange",
                  order: int = 1) ->  MatrixFunction:
    """
    Symbolically compute Cauchy strain
    
    C = F.T @ F

    Parameters
    ----------
    ndim : int
        number of spatial dimensions. Must be between 1 and 3.
    element_type : str
        type of element.
    order : int
        order of element.

    Returns
    -------
    C : symfem.MatrixFunction
        symbolic Cauchy strain of shape (ndim,ndim) 

    """
    #
    F = def_grad(ndim=ndim,
                 element_type=element_type,
                 order=order)
    return simplify_matrix(F.transpose()@F)

def finger_strain(ndim: int,
                  element_type: str = "Lagrange",
                  order: int = 1) ->  MatrixFunction:
    """
    Symbolically compute Finger strain tensor
    
    Finger = inv(C)

    Parameters
    ----------
    ndim : int
        number of spatial dimensions. Must be between 1 and 3.
    element_type : str
        type of element.
    order : int
        order of element.

    Returns
    -------
    Finger : symfem.MatrixFunction
        symbolic Finger strain of shape (ndim,ndim) 

    """
    #
    C = cauchy_strain(ndim=ndim,
                      element_type=element_type,
                      order=order)
    return simplify_matrix( inverse(C) )

def green_strain(ndim: int,
                 element_type: str = "Lagrange",
                 order: int = 1) ->  MatrixFunction:
    """
    Symbolically compute Green strain tensor
    
    B = F @ F.T

    Parameters
    ----------
    ndim : int
        number of spatial dimensions. Must be between 1 and 3.
    element_type : str
        type of element.
    order : int
        order of element.

    Returns
    -------
    B : symfem.MatrixFunction
        symbolic Green strain tensor of shape (ndim,ndim) 

    """
    #
    F = def_grad(ndim=ndim,
                 element_type=element_type,
                 order=order)
    return simplify_matrix(F@F.transpose())
